{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Constants = exports.BarCodeScanner = void 0;\nObject.defineProperty(exports, \"PermissionStatus\", {\n  enumerable: true,\n  get: function get() {\n    return _expoModulesCore.PermissionStatus;\n  }\n});\nexports.usePermissions = exports.scanFromURLAsync = exports.requestPermissionsAsync = exports.getPermissionsAsync = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _expoModulesCore = require(\"expo-modules-core\");\n\nvar React = _interopRequireWildcard(require(\"react\"));\n\nvar _reactNative = require(\"react-native\");\n\nvar _ExpoBarCodeScannerModule = _interopRequireDefault(require(\"./ExpoBarCodeScannerModule\"));\n\nvar _ExpoBarCodeScannerView = _interopRequireDefault(require(\"./ExpoBarCodeScannerView\"));\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nvar BarCodeType = _ExpoBarCodeScannerModule.default.BarCodeType,\n    Type = _ExpoBarCodeScannerModule.default.Type;\nvar EVENT_THROTTLE_MS = 500;\n\nvar BarCodeScanner = function (_React$Component) {\n  (0, _inherits2.default)(BarCodeScanner, _React$Component);\n\n  var _super = _createSuper(BarCodeScanner);\n\n  function BarCodeScanner() {\n    var _this;\n\n    (0, _classCallCheck2.default)(this, BarCodeScanner);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n    _this.lastEvents = {};\n    _this.lastEventsTimes = {};\n\n    _this.onObjectDetected = function (callback) {\n      return function (_ref) {\n        var nativeEvent = _ref.nativeEvent;\n        var type = nativeEvent.type;\n\n        if (_this.lastEvents[type] && _this.lastEventsTimes[type] && JSON.stringify(nativeEvent) === _this.lastEvents[type] && Date.now() - _this.lastEventsTimes[type] < EVENT_THROTTLE_MS) {\n          return;\n        }\n\n        if (callback) {\n          callback(nativeEvent);\n          _this.lastEventsTimes[type] = new Date();\n          _this.lastEvents[type] = JSON.stringify(nativeEvent);\n        }\n      };\n    };\n\n    return _this;\n  }\n\n  (0, _createClass2.default)(BarCodeScanner, [{\n    key: \"render\",\n    value: function render() {\n      var nativeProps = this.convertNativeProps(this.props);\n      var onBarCodeScanned = this.props.onBarCodeScanned;\n      return React.createElement(_ExpoBarCodeScannerView.default, (0, _extends2.default)({}, nativeProps, {\n        onBarCodeScanned: this.onObjectDetected(onBarCodeScanned)\n      }));\n    }\n  }, {\n    key: \"convertNativeProps\",\n    value: function convertNativeProps(props) {\n      var nativeProps = {};\n\n      for (var _i = 0, _Object$entries = Object.entries(props); _i < _Object$entries.length; _i++) {\n        var _ref2 = _Object$entries[_i];\n\n        var _ref3 = (0, _slicedToArray2.default)(_ref2, 2);\n\n        var key = _ref3[0];\n        var value = _ref3[1];\n\n        if (typeof value === 'string' && BarCodeScanner.ConversionTables[key]) {\n          nativeProps[key] = BarCodeScanner.ConversionTables[key][value];\n        } else {\n          nativeProps[key] = value;\n        }\n      }\n\n      return nativeProps;\n    }\n  }], [{\n    key: \"getPermissionsAsync\",\n    value: function getPermissionsAsync() {\n      return _regenerator.default.async(function getPermissionsAsync$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.abrupt(\"return\", _ExpoBarCodeScannerModule.default.getPermissionsAsync());\n\n            case 1:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }\n  }, {\n    key: \"requestPermissionsAsync\",\n    value: function requestPermissionsAsync() {\n      return _regenerator.default.async(function requestPermissionsAsync$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              return _context2.abrupt(\"return\", _ExpoBarCodeScannerModule.default.requestPermissionsAsync());\n\n            case 1:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }\n  }, {\n    key: \"scanFromURLAsync\",\n    value: function scanFromURLAsync(url) {\n      var barCodeTypes,\n          _args3 = arguments;\n      return _regenerator.default.async(function scanFromURLAsync$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              barCodeTypes = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : Object.values(BarCodeType);\n\n              if (_ExpoBarCodeScannerModule.default.scanFromURLAsync) {\n                _context3.next = 3;\n                break;\n              }\n\n              throw new _expoModulesCore.UnavailabilityError('expo-barcode-scanner', 'scanFromURLAsync');\n\n            case 3:\n              if (!(Array.isArray(barCodeTypes) && !barCodeTypes.length)) {\n                _context3.next = 5;\n                break;\n              }\n\n              throw new Error('No barCodeTypes specified; provide at least one barCodeType for scanner');\n\n            case 5:\n              if (!(_reactNative.Platform.OS === 'ios')) {\n                _context3.next = 11;\n                break;\n              }\n\n              if (!(Array.isArray(barCodeTypes) && !barCodeTypes.includes(BarCodeType.qr))) {\n                _context3.next = 8;\n                break;\n              }\n\n              throw new Error('Only QR type is supported by scanFromURLAsync() on iOS');\n\n            case 8:\n              _context3.next = 10;\n              return _regenerator.default.awrap(_ExpoBarCodeScannerModule.default.scanFromURLAsync(url, [BarCodeType.qr]));\n\n            case 10:\n              return _context3.abrupt(\"return\", _context3.sent);\n\n            case 11:\n              _context3.next = 13;\n              return _regenerator.default.awrap(_ExpoBarCodeScannerModule.default.scanFromURLAsync(url, barCodeTypes));\n\n            case 13:\n              return _context3.abrupt(\"return\", _context3.sent);\n\n            case 14:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }\n  }]);\n  return BarCodeScanner;\n}(React.Component);\n\nexports.BarCodeScanner = BarCodeScanner;\nBarCodeScanner.Constants = {\n  BarCodeType: BarCodeType,\n  Type: Type\n};\nBarCodeScanner.ConversionTables = {\n  type: Type\n};\nBarCodeScanner.defaultProps = {\n  type: Type.back,\n  barCodeTypes: Object.values(BarCodeType)\n};\nBarCodeScanner.usePermissions = (0, _expoModulesCore.createPermissionHook)({\n  getMethod: BarCodeScanner.getPermissionsAsync,\n  requestMethod: BarCodeScanner.requestPermissionsAsync\n});\nvar Constants = BarCodeScanner.Constants,\n    getPermissionsAsync = BarCodeScanner.getPermissionsAsync,\n    requestPermissionsAsync = BarCodeScanner.requestPermissionsAsync,\n    usePermissions = BarCodeScanner.usePermissions,\n    scanFromURLAsync = BarCodeScanner.scanFromURLAsync;\nexports.scanFromURLAsync = scanFromURLAsync;\nexports.usePermissions = usePermissions;\nexports.requestPermissionsAsync = requestPermissionsAsync;\nexports.getPermissionsAsync = getPermissionsAsync;\nexports.Constants = Constants;","map":{"version":3,"sources":["../src/BarCodeScanner.tsx"],"names":[],"mappings":"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","sourcesContent":["import {\n  PermissionResponse,\n  PermissionStatus,\n  PermissionHookOptions,\n  createPermissionHook,\n  UnavailabilityError,\n} from 'expo-modules-core';\nimport * as React from 'react';\nimport { Platform, ViewProps } from 'react-native';\n\nimport ExpoBarCodeScannerModule from './ExpoBarCodeScannerModule';\nimport ExpoBarCodeScannerView from './ExpoBarCodeScannerView';\n\nconst { BarCodeType, Type } = ExpoBarCodeScannerModule;\n\nconst EVENT_THROTTLE_MS = 500;\n\n// @needsAudit\n/**\n * Those coordinates are represented in the coordinate space of the barcode source (e.g. when you\n * are using the barcode scanner view, these values are adjusted to the dimensions of the view).\n */\nexport type BarCodePoint = {\n  /**\n   * The `x` coordinate value.\n   */\n  x: number;\n  /**\n   * The `y` coordinate value.\n   */\n  y: number;\n};\n\n// @needsAudit\nexport type BarCodeSize = {\n  /**\n   * The height value.\n   */\n  height: number;\n  /**\n   * The width value.\n   */\n  width: number;\n};\n\n// @needsAudit\nexport type BarCodeBounds = {\n  /**\n   * The origin point of the bounding box.\n   */\n  origin: BarCodePoint;\n  /**\n   * The size of the bounding box.\n   */\n  size: BarCodeSize;\n};\n\n// @needsAudit\n/**\n * > __Note:__ `bounds` and `cornerPoints` are not always available. On iOS, for `code39` and `pdf417`\n * > you don't get those values. Moreover, on iOS, those values don't have to bounds the whole barcode.\n * > For some types, they will represent the area used by the scanner.\n */\nexport type BarCodeScannerResult = {\n  /**\n   * The barcode type.\n   */\n  type: string;\n  /**\n   * The information encoded in the bar code.\n   */\n  data: string;\n  /**\n   * The [BarCodeBounds](#barcodebounds) object.\n   */\n  bounds?: BarCodeBounds;\n  /**\n   * Corner points of the bounding box.\n   */\n  cornerPoints?: BarCodePoint[];\n};\n\n// @docsMissing\nexport type BarCodeEvent = BarCodeScannerResult & {\n  target?: number;\n};\n\n// @docsMissing\nexport type BarCodeEventCallbackArguments = {\n  nativeEvent: BarCodeEvent;\n};\n\n// @docsMissing\nexport type BarCodeScannedCallback = (params: BarCodeEvent) => void;\n\n// @needsAudit\nexport type BarCodeScannerProps = ViewProps & {\n  /**\n   * Camera facing. Use one of `BarCodeScanner.Constants.Type`. Use either `Type.front` or `Type.back`.\n   * Same as `Camera.Constants.Type`.\n   * @default Type.back\n   */\n  type?: 'front' | 'back' | number;\n  /**\n   * An array of bar code types. Usage: `BarCodeScanner.Constants.BarCodeType.<codeType>` where\n   * `codeType` is one of these [listed above](#supported-formats). Defaults to all supported bar\n   * code types. It is recommended to provide only the bar code formats you expect to scan to\n   * minimize battery usage.\n   *\n   * For example: `barCodeTypes={[BarCodeScanner.Constants.BarCodeType.qr]}`.\n   */\n  barCodeTypes?: string[];\n  /**\n   * A callback that is invoked when a bar code has been successfully scanned. The callback is\n   * provided with an [BarCodeScannerResult](#barcodescannerresult).\n   * > __Note:__ Passing `undefined` to the `onBarCodeScanned` prop will result in no scanning. This\n   * > can be used to effectively \"pause\" the scanner so that it doesn't continually scan even after\n   * > data has been retrieved.\n   */\n  onBarCodeScanned?: BarCodeScannedCallback;\n};\n\nexport class BarCodeScanner extends React.Component<BarCodeScannerProps> {\n  lastEvents: { [key: string]: any } = {};\n  lastEventsTimes: { [key: string]: any } = {};\n\n  static Constants = {\n    BarCodeType,\n    Type,\n  };\n\n  static ConversionTables = {\n    type: Type,\n  };\n\n  static defaultProps = {\n    type: Type.back,\n    barCodeTypes: Object.values(BarCodeType),\n  };\n\n  // @needsAudit\n  /**\n   * Checks user's permissions for accessing the camera.\n   * @return Return a promise that fulfills to an object of type [`PermissionResponse`](#permissionresponse).\n   */\n  static async getPermissionsAsync(): Promise<PermissionResponse> {\n    return ExpoBarCodeScannerModule.getPermissionsAsync();\n  }\n\n  // @needsAudit\n  /**\n   * Asks the user to grant permissions for accessing the camera.\n   *\n   * On iOS this will require apps to specify the `NSCameraUsageDescription` entry in the `Info.plist`.\n   * @return Return a promise that fulfills to an object of type [`PermissionResponse`](#permissionresponse).\n   */\n  static async requestPermissionsAsync(): Promise<PermissionResponse> {\n    return ExpoBarCodeScannerModule.requestPermissionsAsync();\n  }\n\n  // @needsAudit\n  /**\n   * Check or request permissions for the barcode scanner.\n   * This uses both `requestPermissionAsync` and `getPermissionsAsync` to interact with the permissions.\n   *\n   * @example\n   * ```ts\n   * const [status, requestPermission] = BarCodeScanner.usePermissions();\n   * ```\n   */\n  static usePermissions = createPermissionHook({\n    getMethod: BarCodeScanner.getPermissionsAsync,\n    requestMethod: BarCodeScanner.requestPermissionsAsync,\n  });\n\n  // @needsAudit\n  /**\n   * Scan bar codes from the image given by the URL.\n   * @param url URL to get the image from.\n   * @param barCodeTypes An array of bar code types. Defaults to all supported bar code types on\n   * the platform.\n   * > __Note:__ Only QR codes are supported on iOS.\n   * @return A possibly empty array of objects of the `BarCodeScannerResult` shape, where the type\n   * refers to the bar code type that was scanned and the data is the information encoded in the bar\n   * code.\n   */\n  static async scanFromURLAsync(\n    url: string,\n    barCodeTypes: string[] = Object.values(BarCodeType)\n  ): Promise<BarCodeScannerResult[]> {\n    if (!ExpoBarCodeScannerModule.scanFromURLAsync) {\n      throw new UnavailabilityError('expo-barcode-scanner', 'scanFromURLAsync');\n    }\n    if (Array.isArray(barCodeTypes) && !barCodeTypes.length) {\n      throw new Error('No barCodeTypes specified; provide at least one barCodeType for scanner');\n    }\n\n    if (Platform.OS === 'ios') {\n      if (Array.isArray(barCodeTypes) && !barCodeTypes.includes(BarCodeType.qr)) {\n        // Only QR type is supported on iOS, fail if one tries to use other types\n        throw new Error('Only QR type is supported by scanFromURLAsync() on iOS');\n      }\n      // on iOS use only supported QR type\n      return await ExpoBarCodeScannerModule.scanFromURLAsync(url, [BarCodeType.qr]);\n    }\n\n    // On other platforms, if barCodeTypes is not provided, use all available types\n    return await ExpoBarCodeScannerModule.scanFromURLAsync(url, barCodeTypes);\n  }\n\n  render() {\n    const nativeProps = this.convertNativeProps(this.props);\n    const { onBarCodeScanned } = this.props;\n    return (\n      <ExpoBarCodeScannerView\n        {...nativeProps}\n        onBarCodeScanned={this.onObjectDetected(onBarCodeScanned)}\n      />\n    );\n  }\n\n  onObjectDetected =\n    (callback?: BarCodeScannedCallback) =>\n    ({ nativeEvent }: BarCodeEventCallbackArguments) => {\n      const { type } = nativeEvent;\n      if (\n        this.lastEvents[type] &&\n        this.lastEventsTimes[type] &&\n        JSON.stringify(nativeEvent) === this.lastEvents[type] &&\n        Date.now() - this.lastEventsTimes[type] < EVENT_THROTTLE_MS\n      ) {\n        return;\n      }\n\n      if (callback) {\n        callback(nativeEvent);\n        this.lastEventsTimes[type] = new Date();\n        this.lastEvents[type] = JSON.stringify(nativeEvent);\n      }\n    };\n\n  convertNativeProps(props: BarCodeScannerProps) {\n    const nativeProps: BarCodeScannerProps = {};\n\n    for (const [key, value] of Object.entries(props)) {\n      if (typeof value === 'string' && BarCodeScanner.ConversionTables[key]) {\n        nativeProps[key] = BarCodeScanner.ConversionTables[key][value];\n      } else {\n        nativeProps[key] = value;\n      }\n    }\n\n    return nativeProps;\n  }\n}\n\nexport { PermissionResponse, PermissionStatus, PermissionHookOptions };\nexport const {\n  Constants,\n  getPermissionsAsync,\n  requestPermissionsAsync,\n  usePermissions,\n  scanFromURLAsync,\n} = BarCodeScanner;\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}